# 计算机网络
## 网络应用层 应用层协议和基础设施
网络应用：社交网络 web 即时通讯 email 流式存储视频 P2P
网络语音 视频会议 搜索 远程登陆

#### 应用层的交互：
1. **CS（客户-服务器模式）**
   **服务器：** 一直运行；固定ip；经常部署于数据中心，方便扩展
   **客户端：** 发起与服务器的通信；可能间歇性连接；可以动态ip；不直接与其他客户端通信
   比如：HTTP IMAP FTP
2. **P2P（对等结构，peer-peer）**
   没有一直在运行的服务器，任意的一端都可以发起通信
   端系统可以向其他端系统请求服务，也可以提供服务
   带来很好的自扩展性：新的端系统带来新请求同时也带来新服务能力
   不过：端系统间歇连接且可改变ip，难以管理
   比如：bitTorrent

#### 进程通信
进程：在主机上运行的应用程序
在同一个主机内，使用操作系统定义的进程间通信机制即可
在不同主机时，通过交换报文(message)来通信
当然，P2P架构中也有客户端进程和服务器进程之分

**分布式进程通信的问题**
进程标示和寻址？
传输层-应用层之间如何提供服务？用层间界面的SAP(TCP/IP:socket)；形式用应用程序借口API(TCP/IP:socket API)
即：定义协议 使用协议

**Sockets 套接字**
本质上是一个API，进程向sockets发送报文或者接受报文
发送进程将报文推到门外，sockets使用传输层设施把报文发给接受进程的sockets **也就是每侧都有一个sockets**

为了接收报文，进程需要有一个表示符 也就是ipv4下主机设备唯一的32位**ip地址和端口号**
ip地址不足以识别进程，因此不同进程通过端口号来区分

**应用层协议：**
定义了：报文的类型（请求 / 应答）
语法（各个字段field的划分）
报文语义（字段中各个值的含义）；定义时间和时序关系

公开协议：由RFC文档定义，任何人都可以访问，允许互操作(HTTP SMTP)
专用协议：Skype Zoom等
*三十年来，互联网中的专用协议增加，各个企业的产品都有自己的专用协议，是不公开的*

服务需求：数据完整性，时效性，吞吐量（带宽，多媒体需要）安全
不同应用，对传输服务的要求不同，有的侧重完整性（文件传输）有的侧重吞吐量（实时音视频 流式音视频）有的侧重时延（交互游戏，即时通讯）

#### 互联网传输层提供的服务
**TCP服务**
发送方和接收方之间的可靠传输；
有流量控制，发送方不会淹没接收方
有拥塞控制，网络拥塞时可以抑制发送方
面向连接，即要求客户端进程和服务器进程同时在线上，要建立连接
但是没有时间保证 最小吞吐量保证 安全保证

**UDP服务**
发送方和接收方之间的不可靠传输（发出去时对方可能不在线，直接丢包）
不提供任何TCP提供的服务，基本上都不支持，仅仅是一个最简单的传输服务

那UDP为什么要存在？
1. 通过端口号区分不同的进程，而IP服务不能
2. 无需建立连接，更快，适合事务性应用和对实时性要求高的应用
3. 有些应用不允许拥塞控制会使用，UDP能按照设定的速度发送数据
4. 目前网络基建良好，UDP也还算稳定

一般，文件下载/email/Web文档/流式音视频：TCP
互联网电话/交互式游戏：TCP or UDP

TCP UDP套接字没有加密，发送到套接字的密码以明文穿越互联网
因此，需要 **TLS Transport Layer Security传输层安全**
在应用层，程序使用TLS库，而TLS库又实用TCP，由此实现加密
***
### Web HTTP
**Web页**
由HTML文件，JPEG图像，JAVA小程序，音频文件等对象组成，每个对象都可能存在不同的Web服务器上
Web页面包含一个基础的HTML文件，包含每个对象的URL

**HTTP: hypertext transfer protocal**
它是web的应用层协议，是CS模型：客户端请求、接收并显示在浏览器
服务器端：web服务器根据请求发送对象（包含一些并发等优化）

进一步，HTTP会调用传输层服务（HTTP使用TCP）
客户端向服务器80端口发起TCP连接，创建套接字
服务器接收TCP连接
之后，浏览器和Web服务器（HTTP服务器）进行HTTP报文交换，直到TCP服务关闭

HTTP是无状态的协议，服务器不维护客户端的状态（维护状态的协议非常复杂，需要维护历史信息且如果一端崩溃，两边的状态会不同）

有两种HTTP连接类型：
1. 非持久HTTP
   TCP连接开放，通过TCP连接发送最多一个对象，TCP就关闭
2. 持久HTTP
   等到所有对象发送完毕，连接再关闭

非持久HTTP：客户端通过URL的80端口建立连接；服务器接收连接并返回通知；客户端再向TCP发送套接字，服务器收到并传对象，同时服务器会关闭连接；
客户端解析并重复这个过程，直到每一个对象的URL都访问完并接收完

为此，定义响应时间RTT：一个小数据包从客户端到服务器再返回到时间
$$非持久 HTTP 响应时间 =  2RTT+ 文件传输时间$$
*文件传输时间，是服务器把文件上传的时间，不是传播时间*

每个对象需要两个RTT，且每个TCP都要操作系统开销
因此，产生了**持久HTTP（HTTP1.1）**
服务器在发送响应后，仍保持TCP连接开放
同一客户端/服务器之间通过开放连接发送后续HTTP报文
客户端在遇到引用对象时立即发送请求
对所有引用对象的响应时间仅为一个 RTT（响应时间缩短一半）

**HTTP请求报文**
使用ASCII实现的
请求行：GET/POST URL等
HEADER首部 描述一些浏览器信息等等
报文体（这个可以为空）

还有HEAD 方法：只返回同一 URL 被 GET 方法请求时，响应报文的请求头部分
PUT方法：向服务器上传新对象（文件等）

**HTTP响应报文**
状态行：如`HTTP/1.1 200 OK`
首部行
数据

**常见响应状态代码**
200 OK 请求成功，请求的对象在该报文后续部分
301 Moved Permanently 请求的对象已经被永久转移，新的地址在该报文的Location: 域中指定（也就是所谓：重定向）
400 Bad Request 服务器无法理解请求报文
404 Not Found 服务器上没有找到请求的文档
505 HTTP Version Not Supported
*netcat命令 nc -c -v gaia.cs.umass.edu 80 (for Mac)*

**维护客户/服务器状态：cookies**
HTTP GET响应和交互是无状态的，所有请求都是独立的
好处：网络连接或客户端崩溃会导致互斥、上锁功能可能出现死锁；
客户端/服务器无需从部分完成但从未完全完成的事务中 "恢复"

那么，如果需要维护客户端/服务器状态，使用cookies

四个组成部分：
1) HTTP响应报文中的cookie首部行
2) HTTP请求报文中的cookie首部行
3) 在客户端系统中保存、由用户浏览器管理的cookie文件
4) Web 站点的后端数据库

当初始HTTP请求到达网站时，网站会创建：唯一ID（cookie）
向本网站发出的后续 HTTP 请求将包含 cookie ID 值

Cookies可以用于授权、购物车、推荐、用户会话状态（已读未读..）

还存在：第三方持久性 cookie（跟踪 cookie）允许在多个网站上跟踪共同身份（cookie 值）
跟踪可能对用户不可见：
不是显示广告触发 HTTP GET 到跟踪器，可能是一个隐形链接，产生隐私问题 近几年的浏览器和欧盟在逐渐禁用

**Web缓存（aka代理服务器）**
在不涉及源服务器的情况下满足客户请求
用户将浏览器配置为指向（本地）Web 缓存
浏览器将所有 HTTP 请求发送到缓存
如果对象在缓存中：缓存将对象返回给客户
否则，缓存从源服务器请求对象，缓存接收到的对象（报文会标注服务器是否允许缓存），然后将对象返回给客户
*对于浏览器请求来说是服务器；对于源服务器来说是客户端*
**Web 缓存的意义：**
降低客户请求获得响应的时间（缓存离客户更近）
减少机构接入链路的流量
互联网上有大量缓存，使内容提供商能够更有效地提供内容

接入网络高利用率下排队延迟大，而接入链路非常昂贵；LAN(local area network)利用率很低。这时如果使用缓存，假设缓存命中率0.4，接入链路利用率减小，延迟大大减小